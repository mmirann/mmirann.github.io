---
layout: post
title: "[운영체제] 🦕 Operating System: Concepts Ch.1-1"
subtitle: ""
categories: [Study/OS]
tags:
comments: true
---

## 1. 서론

---

**운영체제의 역할**

- 컴퓨터 하드웨어를 관리하는 프로그램
- 응용 프로그램을 위한 기반 제공
- 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할 수행

위와 같은 일을 수행하기 위해서 다양한 방법이 존재한다.

- 대형 컴퓨터의 운영체제는 주로 하드웨어의 이용을 최적화하는데 주를 둠
- 퍼스널 컴퓨터 운영체제는 복잡한 게임, 비즈니스 응용을 지원함
- 휴대용 컴퓨터 운영체제는 사용자가 프로그램을 수행하기 위해 컴퓨터와 쉽게 인터페이스 할 수 있는 환경을 제공

따라서 어떤 운영체제는 일반인이 사용하기에 편하도록 설계되었고 일부는 효율성에, 일부는 이들의 조합으로 설계되었다.

<br>

## 1.1 운영체제가 할 일

---

**컴퓨터 시스템의 네 가지 구성 요소**

- 하드웨어: 중앙 처리 장치(CPU), 메모리, I/O 장치로 구성되어 기본 계산용 자원 제공
- 응용 프로그램: 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될지 정의
- 운영체제: 다양한 사용자를 위해 다양한 응용 프로그램 간의 하드웨어 사용을 제어하고 조정
- 사용자

운영체제는 정부와 유사하다. 운영체제는 정부처럼 그 자체로는 유용한 기능을 수행하지 못하지만, **다른 프로그램이 유용한 작업을 할 수 있는 환경을 제공**한다. 운영체제의 역할은 사용자와 시스템 두 관점으로 살펴볼 수 있다.

<br>

### 1.1.1 사용자 관점(User View)

---

컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.

1. 모니터, 키보드, 마우스로 구성된 PC 앞에서 작업하는 경우
   - OS는 대부분 사용의 용이성을 위해 설계되고, HW와 SW 자원이 어떻게 공유되느냐(Resource utilization)는 신경쓰지 않음
2. 대형 컴퓨터나 미니 컴퓨터에 연결된 터미널에 앉아있는 경우
   - 사용자들이 자원을 공유하고 정보를 교환하므로 OS는 자원 이용을 극대화하도록 설계됨
3. 워크스테이션과 서버의 네트워크에 연결된 워크스테이션에 앉아있는 경우
   - OS는 개인의 사용 용이성과 자원 이용 간에 적절한 조화를 이루도록 설계

<br>

### 1.1.2 시스템 관점(System View)

---

1. 운영체제는 **자원 할당자**(Resource allocator)
   - 컴퓨터의 관점에서 OS는 하드웨어와 가장 밀접하게 연관된 프로그램
   - CPU 시간, 메모리 공간, 파일 저장 공간, IO장치 등의 자원 관리자로 동작하고, 작업을 위해 특정 프로그램과 사용자에게 필요한 자원을 할당
2. 운영체제는 **제어 프로그램**(Control program)
   - 에러를 막기 위해 프로그램 수행 제어, 입출력 장치의 제어, 작동에 관여

<br>

### 1.1.3 운영체제의 정의

---

운영체제에 대한 완벽한 정의는 없다. 운영체제는 유용한 컴퓨터 시스템을 만드는 과정에서 발생하는 문제점을 해결하기 위한 적절한 방법이기 때문에 존재한다.

- 컴퓨터 시스템의 근본 목적인 사용자 프로그램을 실행하고, 문제의 해결하기 위해 컴퓨터 하드웨어가 제작됨
- 순수 하드웨어만으로는 사용이 어려워 응용 프로그램이 개발됨
- 다양한 프로그램은 IO장치의 통제와 같은 공통 연산이 필요한데 자원을 제어하고 할당하는 공통 기능을 하나의 소프트웨어로 통합하기 위해 운영체제가 제작됨

보다 일반적인 정의로 **운영체제는 컴퓨터에서 항상 수행되는 프로그램으로 일반적으로 커널**이라고 불린다.

<br>

## 1.2 컴퓨터 시스템의 구성(Computer System Organization)

### 1.2.1 컴퓨터 시스템 연산(Computer-System Operation)

---

**Computer Startup**

- 컴퓨터가 구동을 시작하기 위해선 **부트스트랩 프로그램(Bootstrap Program)** 이라는 초기 프로그램이 적재됨
- 이것은 펌웨어라고 알려져 있는 컴퓨터 내의 ROM(Read-Only Memory)나 EEPROM에 저장됨
- CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화함
- 부트 스트랩 프로그램은 운영체제의 커널을 찾아 메모리에 적재하고 수행을 시작함 -> 사용자에게 서비스 제공

**Computer System Organization**

![image](https://user-images.githubusercontent.com/48276682/131243214-a8d9d6ff-c2b4-48c6-81ed-a3cb06c733aa.png)

- 현대의 컴퓨터 시스템은 공유 메모리(shared memory)에 대한 접근을 제공하는 공통 버스에 의해 연결된 여러 개의 장치 제어기(device controller)와 하나 이상의 CPU로 구성되어 있음
- 각 **장치 제어기**는 디스크 드라이브, 오디오 장치, 비디오 디스플레이 등의 특정 장치를 관리하고 있으며 Input과 Output의 속도가 달라 local buffer를 가짐
- **CPU**는 메인메모리에서 장치 제어기의 lcoal buffer로 데이터를 이동함
- CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하며 병렬 수행될 수 있음
- 공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공되며, 메모리 접근을 동기화 함

**Interrupts**

![image](https://user-images.githubusercontent.com/48276682/131243422-8cbb9630-9bad-4fb9-a252-4ccc54d145e5.png)

Event가 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 **인터럽트**에 의해 신호가 보내진다. 컴퓨터는 여러 작업을 동시에 실행하는데 당장 처리해야 하는 일이 생겨 기존의 작업을 잠시 중단해야하는 경우 인터럽트 신호를 보낸다. 이 때 커널은 작업을 멈추고 인터럽트를 처리한 뒤 기존 작업으로 돌아온다.

- **하드웨어**는 어느 순간이든 **시스템 버스**를 통해 CPU에 신호를 보내 인터롭트를 발생시킬 수 있음
- **소프트웨어**는 **System call**을 실행하여 인터럽트를 발생시킬 수 있고 이를 **트랩**(Trap) 또는 **예외**(Exception)라고 부르며 오류나 사용자 요청으로 인해 발생함

**Common Functions of Interrupts**

- CPU가 인터럽트되면 CPU는 하던 일을 중단하고, 고정된 위치로 실행을 옮김
- 인터롭트는 일반적으로 모든 서비스 루틴의 주소를 포함하는 **인터럽트 벡터**(Interrupt Vector)를 통해 인터럽트를 처리할 수 있는 인터럽트 서비스 루틴(Service routine)으로 제어 권한을 전송함

**Interrupt Handling**

- 현재 운영체제들은 인터럽트 주도적(Interrupt driven)임
- 인터럽트는 적절한 서비스 루틴으로 제어를 전달하기 위해 인터럽트 정보를 조사하는 일반적인 루틴을 호출하고 이 루틴은 **인터럽트 고유의 핸들러**(handler)를 호출함

<br>

### 1.2.2 저장 장치 구조

---

CPU는 명령어를 단지 메모리로부터 가져올 수 있으므로 프로그램을 수행하기 위해선 프로그램이 반드시 메모리에 있어야 하며 커널이 이것을 메모리에 할당해 실행한다. 이처럼 모든 프로그램은 **메인 메모리(RAM)**에 로드되어 실행된다. 컴퓨터는 ROM, EEPROM 등 다른 형태의 메모리도 사용하는데 **ROM**은 변경할 수 없으므로 부트스트랩 프로그램 같은 정적 프로그램을 저장한다. **EEPROM**은 변경할 수 있으나 자주 변경할 수 없으므로 대부분 정적 프로그램을 저장한다. 스마트폰은 공장에서 설치한 프로그램을 사용하기 위해 EEPROM을 사용한다.

- Load: 메인 메모리(RAM)으로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮김
- Store: 레지스터의 내용을 주 메모리로 옮김

**Main Memory**

- 보통 RAM(Random-Access Memory)라고 부름
- DRAM(Dynamic RAM)이라고 불리는 반도체 기술로 구현됨
- 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작음
- 메인 메모리는 전원이 공급되지 않으면 내용을 잃어버리는 휘발성 저장장치

**Secondary Storage**

- 메인 메모리의 위와 같은 특성때문에 메인 메모리의 확장으로 보조 저장 장치 제공
- 비휘발성 기억장치(Non-volatile): 자기 디스크(Magnetic disk), 광학 디스크(Optical disk), 자기 테이프(Magnetic tapes), SSD(Solid-State Disk) 등
- 휘발성 기억장치(Volatile): 캐시(Cache), 레지스터(Register) 등

**Caching**

- 하드웨어, 운영체제, 소프트웨어 등 컴퓨터의 여러 레벨에서 수행되는 중요한 원칙
- 사용 중인 정보를 느린 저장소에서 빠른 저장소로 일시적으로 복사함
- 정보가 있는지 확인하기 위해 빠른 저장소(캐시)를 먼저 확인함
- 캐시에 존재하지 않는 경우 캐시에 데이터를 복사하여 캐시에서 사용함

<br>

### 1.2.3 입출력 구조

---

저장 장치는 컴퓨터 내의 여러 형태의 입출력 장치 중 하나이다. **장치 제어기**(device controller)는 자신이 제어하는 주변 장치와 자신의 로컬 버퍼 저장 장치 사이의 데이터 전송을 담당한다. 통상적으로 운영체제는 각 장치 제어기마다 디바이스 드라이버를 가지고 있다.

**IO 연산**을 위해 디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재한다. 장치 제어기는 "키보드에서 한 문자를 읽어오라" 등의 취할 동작을 결정하기 위해 레지스터의 내용을 조사한다. 제어기는 장치로부터 자신의 로컬 버퍼로 데이터 전송을 시작하고 데이터의 전송이 완료되면 완료했음을 **인터롭트**를 이용해 디바이스 드라이버에게 통보한다. 디바이스 드라이버는 제어를 운영체제에게 반환한다.

**DMA**(Direct Access Mememory)

위의 인터롭트 구동 방식의 입출력은 적은 양의 데이터를 전송하는 데에는 문제가 없으나 디스크 입출력과 같은 대량의 데이터를 전송하는 데에는 높은 오버해드를 초래한다.

![image](https://user-images.githubusercontent.com/48276682/144812021-4cb56dab-8da1-484c-947c-51900ce6b661.png){: width="50%" height="50%"}

- **CPU의 개입없이** 메모리로부터 장치 제어기 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송함
- 한 바이트마다 인터럽트가 발생하는 것이 아닌 블록 전송이 완료될 때마다 인터롭트가 한번만 발생
- 장치 제어기가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행

<br>

## 1.3 컴퓨터 시스템 구조 (Computer-System Architecture)

### 1.3.2 Multiprocessor System

---

멀티 프로세서는 2개 이상의 프로세서를 가지며 컴퓨터 버스, 때로는 클락, 메모리와 주변 장치를 공유한다.

- **Multiprocessor**: CPU가 여러 개
- **Multi Core**: 하나의 CPU에 여러 개의 코어

**멀티프로세서 시스템의 장점**

- **증가된 처리량**(throughput): 짧은 시간동안 많은 일 수행
- **규모의 경제**: 주변 장치를 공유하기 때문에 여러 대의 싱글 프로세서를 사용하는 것보다 비용을 줄일 수 있음
- **증가된 신뢰성**: 하나의 프로세서가 고장나도 다른 프로세서가 작동 중임. 이렇게 성능은 나빠지지만 작동은 가능한 것을 우아한 퇴보 (graceful degradation) 라고 함. 또한 한 구성요소의 고장에도 불구하고 작동을 계속할 수 있는 것은 우아한 퇴보를 넘어 결함 허용(fault tolerant)라고 함.

**멀티 프로세서 시스템의 형태**

- **비대칭적 다중 처리**(asymmetric multiprocessing): 하나의 주 프로세서가 시스템을 제어하고 다른 프로세서들은 주 프로세서의 명령을 수행하거나 미리 정의된 테스크를 수행함. 부하 분산(load balancing)은 효율적이지만 주 프로세서가 작동을 멈추면 부하 프로세서들 또한 작동을 멈춤.

![image](https://user-images.githubusercontent.com/48276682/132084755-f538128e-d1b6-4788-83b5-f626e13e2643.png)

- **대칭적 다중 처리**(symmetric multiprocessing): 프로세서 간의 주종 관계가 없으며 하나의 메모리를 공유함. 대부분의 컴퓨터 시스템 구조.

위의 사진에서 볼 수 있듯이 각 프로세서는 자신의 레지스터 집합과 캐시를 갖는다.

**Dual-core**

단일 코어를 가진 여러 개의 칩보다 효율적이며, 이는 칩 내의 통신이 칩 사이의 통신보다 빠르기 때문이다. 또한 여러 개의 단일 칩보다 전력을 훨씬 덜 소모한다. 멀티 코어 시스템은 멀티 프로세서 시스템인 반면 모든 멀티 프로세서 시스템이 멀티 코어인 것은 아니다.

![image](https://user-images.githubusercontent.com/48276682/132084846-b41f5012-82b8-490b-a513-2d5ff09e29d9.png){: width="50%" height="50%"}

각 코어는 자신의 레지스터 집합과 자신의 로컬 캐시를 갖으며 하나의 캐시를 공유하기도 한다.

<br>

### 1.3.3 클러스터형 시스템(Clustered Systems)

---

둘 이상의 노드(싱글 프로세서 or 멀티 프로세서)가 하나의 일을 처리한다. 이러한 시스템은 약결합(loosely coupled)라고 간주된다. 클러스터링은 통상 높은 가용성(availability)를 제공하기 위해 사용된다. 즉 클러스트 내 하나 이상의 컴퓨터 시스템이 고장나도 서비스는 계속 제공된다.

![image](https://user-images.githubusercontent.com/48276682/132085214-ba691957-4d05-4c22-8618-951e194b6973.png){: width="50%" height="50%"}

- **대칭형**: 둘 이상의 호스트들이 응용 프로그램을 실행하고 서로를 감시함. 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이 더욱 효율적임.
- **비대칭형**: 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 긴급대기(hot-standby)모드 상태를 유지함. 서버가 고장나면 긴급 대기 모드의 호스트가 활성 서버가 됨.

클러스터 시스템은 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있어 단일 프로세서나 SMP 시스템보다 훨씬 큰 계산 능력을 제공할 할 수 있다.

