---
layout: post
title: "[운영체제] 🦕 Operating System: Concepts Ch.1-2"
subtitle: ""
categories: [Study/OS]
tags:
comments: true
---

## 1.4 운영체제의 구조

---
**Multiprogramming**  

멀티 프로그래밍은 CPU가 수행할 작업(코드와 데이터)을 항상 하나 가지도록 작업을 구성하여 CPU 이용률을 증가시킨다. 즉, 여러 프로그램을 메모리에 로드하고 한 프로세스(ex.IO)를 기다리는 동안 다른 프로세스의 작업을 수행하는 시스템이다.  

멀티 프로그래밍의 아이디어는 다음과 같다. OS는 한 번에 여러 작업을 메모리에 적재한다. 이 작업은 처음에 디스크의 작업 풀(pool)에 유지되어 메인 메모리의 할당을 기다린다. **Job scheduling**에 의해 하나의 작업이 선택되고 실행된다. 선택된 작업은 입출력의 종료를 기다리는 등과 같이 어떤 일을 기다려야 할 때 다른 작업으로 전환해 작업을 수행함으로써 CPU가 쉬지 않게 한다.  

* Multiprogramming: OS 구조
* Multiprocessing: 컴퓨터 구조

**TimeSharing(multitasking)**  

시분할 시스템은 멀티 프로그래밍의 확장으로, 프로세스마다 작업 시간을 정해두고 번갈아가면서 작업하는 방식이다. CPU가 다수의 작업을 교대로 수행하지만, 매우 빈번하게 교대가 일어나 프로그램이 실행되는 동안 사용자는 동시에 작용하는 것처럼 느낀다. **프로세스**는 메모리에 적재되어 있고, 실행되고 있는 프로그램을 뜻하며 자신이 종료되거나 입출력을 수행할 필요가 있을 때까지 아주 짧은 시간 동안만 실행된다.  

사용자는 키보드나 마우스 같은 입력장치를 이용해 명령하고 출력 장치의 즉각적인 응답을 기다리기 때문에 응답시간(Response Time)이 짧아야 한다. 시분할 시스템에서 동작과 명령은 대체로 짧기 때문에 짧은 시간동안만 CPU 시간이 필요하다.  적절한 응답시간은 **스와핑**에 의해 달성되는데, 스와핑은 주 메모리에서 디스크로 적절하게 스왑인, 스왑아웃 시킨다. 응답시간을 더 합리적으로 보장하기 위해 **가상메모리**(Virtual Memory)
를 사용한다. 프로그램이 실제메모리(Physical Mememory)보다 크기가 더 커도 되며 9장에서 다룬다.

* 시분할 시스템에서 파일 시스템은 다수의 디스크 상에 존재하므로, 디스크 관리 기법이 반드시 제공되어야함(12장) 
* 자원을 보호하는 기법을 제공해야 함(14장) 
* 작업이 질서정연하게 실행되기 위해 시분할 시스템은 작업 동기화와 통신 기법을 제공해야 함(6장)
* 작업이 데드락에 걸리지 않게 해야 함(7장)

**Scheduling**  

시분할과 멀티프로그래밍 모두 여러 작업을 동시에 메모리에 올리는 방식이다.
* **Job Scheduling**(작업 스케쥴링, 5장):OS는 메모리에 자리가 없는 경우를 고려해 어떤 것을 실행할 지 선택해야 함
* **CPU Scduling**(5장): 여러 개의 작업이 동시에 실행 준비가 되어 있으면 시스템은 그들 중 하나를 선택해야 함

메모리에 여러 개의 프로그램이 동시에 있는 경우 메모리 관리가 필요한 데 이는 8장,9장에서 다룬다.

<br>

## 1.5 운영체제 연산
---
현대의 운영체제는 **인터럽트 구동식**(Interrupt Driven)이다. Event는 항상 인터럽트나 트랩을 발생시켜 신호를 보낸다. **트랩(또는 예외)**은 오류(0으로 나누기, out of index 등) 또는 사용자 프로그램이 OS 서비스 수행 요청에 의해 유발되는 **소프트웨어에 의해 생성된 인터럽트**이다.  

<br>

### 1.5.1 Dual-mode operation
---
OS의 적절한 동작을 보장하고 OS코드의 실행과 사용자 정의 코드의 실행을 구분하기 위해 사용자 모드와 커널 모드, 두 개의 독립된 연산 모드를 필요로 한다. 

![image](https://user-images.githubusercontent.com/48276682/144814039-9d6c638f-be90-4eec-be6e-40739c00578c.png)

* 커널 모드의 하드웨어 모드 비트: 0
* 사용자 모드의 하드웨어 모드 비트: 1

시스템 부트 시, 하드웨어는 커널 모드에서 시작한다. 그 후 OS가 적재되고, 사용자 모드에서 사용자 프로세스가 시작된다. 트랩이나 인터럽트가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 하드웨어는 커널 모드일 때마단 **특권 명령**(priviledged instruction)을 실행한다. 사용자 모드에서 이를 수행하려고 시도하면 하드웨어는 OS로 트랩을 건다. 특권 명령에는 커널 모드의 전환, IO 제어, 타이머 관리, 인터럽트 관리를 위한 명령어들이다. 

 **시스템 호출(System call)**  
사용자가 커널 모드의 기능을 호출하기 위한 방법으로, 사용자 프로그램이 자신을 대신해 OS가 수행하도록 지정된 작업을 OS에게 요청할 수 있는 방법을 제공한다. 호출은 Trap, Syscall 명령어를 통해 인터렙트 벡터의 특정 위치로 트랩을 거는 형태로 이루어진다. 시스템 호출이 수행되면 시스템 호출은 하드웨어에 의해 **하나의 소프트웨어 인터럽트**로 취급되며, 제어가 인터럽트 벡터를 통해 OS내의 서비스 루틴으로 전달되고 모드 비트가 커널 비트로 설정된다.  

<br>

### 1.5.2 Timer
---
사용자 프로그램이 무한루프에 빠지거나 시스템 서비스 호출에 실패해 제어가 OS로 복귀하지 않는 경우 등 프로세서의 자원 소모 방지를 위해 CPU에 대한 제어 유지를 보장할 때 사용된다. 타이머는 지정된 시간 후 컴퓨터를 인터롭트하도록 설정한다. 타이머가 인터럽트를 발생하면, 제어는 자동적으로 OS에게 넘어간다. 

<br>

## 1.6 프로세스 관리
---
* **프로그램**: 디스크에 저장된 파일의 내용과 같이 수동적(passive) 개체
* **프로세스**: 메모리에 로드된 실행 중인 프로그램. 다음 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적인(active) 개체
* **스레드**: 프로그램의 흐름을 여러 개로 쪼갬. 스레드마다 PC를 가짐

프로그램은 하나지만 프로세스는 여러 개일 수 있다. 싱글 스레드 프로세스는 하나의 PC를 가지고 있으며 멀티 스레드 프로세스는 여러 개의 PC를 가질 수 있다. 한 프로세스는 한 시스템 내의 작업의 단위이다. 이러한 시스템은 프로세스의 집합으로 구성되는데, 프로세스들 중 일부는 OS 프로세스들이며, 나머지는 사용자 프로세스들이다. 이 모든 프로세는 그들 간에 하나의 CPU를 **멀티플렉싱**(multiplexing)함으로써 병행 수행될 수 있다.(3장, 6장) 운영체제는 프로세스 관리에 대해 다음과 같은 책임을 진다.

* CPU 프로세스와 스레드를 스케줄하기
* 사용자 프로세스와 시스템 프로세스의 생성과 제거
* 프로세스의 일시 중지와 재수행
* 프로세스 동기화/ 통신을 위한 기법 제공

<br>

## 1.7 메모리 관리
---
메인 메모리는 CPU와 IO장치에 의해 공유되는 빠른 접근이 가능한 데이터의 저장소이다. 폰 노이만 방식의 컴퓨터에서는 다음과 같이 동작한다.

* 명령어 인출 주기(instruction fetch-cycle): 동안 메인 메모리로부터 명령어를 읽음
* 자료 인출 주기(data fetch-cycle): 동안 메인 메모리로부터 데이터를 읽고 씀

프로그램이 수행되기 위해서 반드시 절대 주소로 매핑되고, 메모리에 적재되어야 한다. 메모리 공간을 할당하고 해제하는 것은 운영체제의 역할이다. (8장, 9장)

<br>

## 1.8 저장장치 관리
---
 
![image](https://user-images.githubusercontent.com/48276682/144825749-9a82f55a-ad8b-4f55-a446-91a08ca4701f.png)

운영체제는 저장 장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의한다. 운영체제는 파일을 물리적 매체로 매핑하며, 저장 장치를 통해 이들 파일에 접근한다.  

<br>

### 1.8.1 파일 시스템 관리
---
운영체제는 테이프와 디스크와 같은 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다. 또한 파일은 사용을 쉽게 하기 위해 디렉토리들로 구성된다. 운영체제는 파일 관리를 위해 다음과 같은 일을 담당한다. (10장, 11장)

* 파일/ 디렉토리의 생성 및 제거 
* 파일을 보조 저장 장치로 매핑
* 파일과 디렉토리 조작을 위한 프리미티브 제공
* 안정적인 비휘발성 저장 매체에 파일을 백업

<br>

### 1.8.2 대용량 저장 장치 관리
---
컴퓨터 시스템은 반드시 메인 메모리 내용을 저장하기 위해 보조 저장 장치를 제공해야 한다. 운영체제는 디스크 관리르 위해 다음과 같은 기능을 담당한다.

* 자유 공간(free-space)의 관리
* 저장 장소 할당
* 디스크 스케줄링  

<br>

### 1.8.3 캐싱(caching)
---
캐시는 매우 빠르고 작은 저장장치이며, 캐시 메모리를 사용해 컴퓨터의 속도를 높인다. 특정 정보가 필요한 경우 캐시에 먼저 접근해 정보가 있는지 조사하고, 있으면 캐시로부터 직접 사용하지만 없다면 메인 메모리에서 그 정보를 가져와 사용한다. 이 정보는 또 다시 사용될 가능성이 높기 때문에 캐시에 저장된다. 캐싱은 **지역성**의 원리를 사용한다.

* 시간 지역성(Temporal Locality): 한 번 접근한 데이터에 다시 접근할 확률이 높음
* 공간 지역성(Spatial Locality): 특정 데이터와 가까운 메모리 주소에 있는 다른 데이터들에게도 접근할 가능성이 높음

**캐시 일관성 문제**는 CPU가 여러 개의 프로세스들 사이에서 이리 저리 전환되는 멀티 태스킹 환경에서 발생할 수 있다. 여러 개의 프로세스가 특정 값에 접근하기 위하는 경우, 이들 각 프로세스가 가장 최근에 갱신된 해당 값을 얻을 수 있는 것이 보장되지 않았을 때 발생하며 하드웨어적 문제이다. 

<br>

### 1.8.4 입출력 시스템(I/O System)
---
입출력 시스템은 다음과 같이 구성되어 있다. 운영체제는 사용자에게 특정 하드웨어 장치의 특성을 숨기며 단지 장치 드라이버만이 자신에게 지정된 특정 장치의 특성을 알고 있다. 

* 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성 요소
* 일반적인 장치 드라이버 인터페이스
* 특정 하드웨어 장치들을 위한 드라이버

<br>

## 1.9 보호와 보안
---
보호의 기능을 갖고 있어도 공격을 당할 수 있다. 그 때 필요한 것이 보안이다. 

* 보호: 자원에 접근하는 것을 제어 (ex. 듀얼 모드)
* 보안: 시스템을 망가뜨리는 것을 막음

