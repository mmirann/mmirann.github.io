---
layout: post
title: "[운영체제] 🦕 Operating System: Concepts Ch.2"
subtitle: ""
categories: [Study/OS]
tags:
comments: true
---

## 2. 시스템 구조

---

- 운영체제가 사용자, 프로세스 및 다른 시스템에게 제공하는 서비스가 무엇인지
- 운영체제를 구성하는 여러 방법
- OS 설치 방법, 맞춤화 과정 및 부팅과정

<br>

## 2.1 운영체제 서비스

---

운영체제는 사용자와 시스템에게 서비스를 제공한다.
![image](https://user-images.githubusercontent.com/48276682/145669752-29de5d6e-7c3c-4848-9b69-da8e7406858a.png){: width="70%" height="70%"}

- **사용자 인터페이스**(UI)

  - 명령어 라인 인터페이스(CLI): **프로그램 셸**을 통해 문자열 명령을 내림
  - 배치 인터페이스: 명령어와 명령어를 제어하는 디렉티브가 파일 형태로 입력되고 그 파일이 실행됨
  - 그래피컬 사용자 인터페이스(GUI): 입출력을 지시하고, 메뉴를 선택하여 키보드로 문자열을 입력할 수 있는 위치 결정 장치를 가지는 시스템
    <br>

- **프로그램 수행**(Program execution)

  - 시스템은 프로그램을 메모리에 적재해 실행
  - 프로그램은 정상적이든, 비정상적이든 실행을 끝낼 수 있어야 함

- **입출력 연산**(I/O Operation)

  - 수행 중인 프로그램은 입출력을 요구할 수 있는데 효율과 보호를 위해 사용자들은 입출력 장치를 직접 제어할 수 있음
  - 따라서 OS가 입출력 수행의 수단을 제공

- **파일 시스템 조작**(File System Manipulation)

  - 프로그램은 파일 생성, 삭제 및 탐색, 읽고 쓰기를 할 수 있음.
  - 또한 파일 소유권에 기반을 둔 권한 관리를 이용해 파일이나 디렉토리의 접근을 허가하거나 거부할 수 있음

- **통신**(Communication)

  - 한 프로세스가 다른 프로세스와 정보를 교환해야할 때, OS는 공유 메모리(Shared Memory)나 메시지 패싱(Message Passing)을 사용할 수 있음
  - 후자의 경우 정보의 패킷들이 운영체제에 의해 프로세스 사이를 이동

- **오류 탐지**(Error detection)
  - OS는 CPU, 메모리 하드웨어, 입출력 장치 또는 사용자 프로그램에서 일어나는 오류를 탐지하고 적당한 조치를 취해야 함

사용자에 도움을 주는 것이 목적이 아니라 시스템 자체의 효율적인 동작을 보장하기 위한 운영체제 기능들도 존재한다.

- **자원 할당**(Resource Allocation)

  - 다수의 사용자나 다수의 작업들이 동시에 실행될 때, 각각에 자원을 할당해주어야 함

- **회계**(Accounting)

  - 사용자가 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지 추적, 사용 통계는 컴퓨팅 서비스를 개선하기 위해 사용

- **보호**(Protection)와 **보안**(Security)
  - 보호는 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것
  - 보안은 네트워크 어댑터 등 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입 탐지를 위해 모든 접속을 기록
  - 시스템이 보호되고 보안이 유지되려면 시스템 전체에 걸쳐 예방책(precaution)이 제정되어야 함

<br>

### 2.3 System Calls

---

**System Call**은 운영체제에 의해 사용 가능하게된 서비스에 대한 인터페이스를 제공한다. 특정 저수준 작업은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C와 C++ 언어로 작성된 루틴 형태로 제공된다.

![image](https://user-images.githubusercontent.com/48276682/146886943-b12a9050-ec9b-4e9b-be98-b5f542e948b8.png){: width="70%" height="70%"}

간단한 프로그램이라도 운영체제의 기능을 많이 사용하게 되는데 대부분의 응용 개발자들은 **응용 프로그래밍 인터페이스 (API)**에 따라 프로그램을 설계한다. API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할 수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.

![image](https://user-images.githubusercontent.com/48276682/146887441-b550ad45-cebb-4ead-b805-5192e7edb7ca.png){: width="70%" height="70%"}

**System call Interface**는 API 함수의 호출을 가로채 필요한 운영체제 System call을 부른다. 일반적으로 각 System call에는 번호가 할당되고 System call Interface는 이 번호에 따라 색인되는 테이블을 유지한다. 이것을 **System call table**이라고 부르며, **인터럽트 벡터**라고도 부른다. 메모리 주소의 모음이며 해당 메모리 주소는 인터럽트 서비스 루틴을 가르키고 있다. System call Interface는 의도한 System call을 부르고 System call의 상태와 반환 값을 돌려준다.

사용자 프로그램이 운영체제에 매개변수를 전달하는 방법은 3가지가 있다.

- **Call by value**: 매개변수 값 자체를 복사해 레지스터 내에 전달
- **Call by reference**: 레지스터보다 매개변수가 더 많은 경우 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달됨
- 프로그램에 의해 스택에 push, OS에 의해 pop

<br>

## 2.4 System call 유형

---

- 프로세스 제어: `end`,`abort`,`load`,`execute`
- 파일 관리: `create`, `delete`, `open`, `close`, `read`, `write`
- 장치 관리: `read`, `write`, `request`, `release`
- 정보 유지: `get/set time/date`
- 통신: `send/recieve messages`, `transfer status`
- 보호

<br>

## 2.5 System Program

---

- 컴퓨터 계층 구조: 하드웨어 -> 운영체제 -> 시스템 프로그램 -> 응용 프로그램

시스템 프로그램은 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 보다 편리한 환경을 제공한다.

- 파일관리, 상태 정보, 파일 변경, 프로그래밍언어지원, 프로그램 적재와 수행, 통신, 백그라운드 서비스
- 항상 실행되는 시스템 프로그램 프로세스-> 서비스, 서브시스템, 디먼(연결 받을 프로세스)
- 모두 System call을 통해 구현

<br>

## 2.6 운영체제 설계 및 구현

---

### 운영체제의 설계 목표

- User: 사용하기 쉽고, 배우기 쉽고, Reliable, safe and fast
- System: 유지보수가 쉽고, 에러가 없으며 자원 효율적

### 기법과 정책

- **기법**(Mechanism): 어떻게 할 것인가
- **정책**(Policy): 무엇을 할 것인가 -> 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있음  
  예를 들면 타이머 구조는 CPU 보호를 보장하기 위한 기법이지만, 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할지를 결정하는 것은 정책적 결정이다. 정책과 기법의 분리는 융퉁성을 위해 아주 중요하다. 정책의 변경에 민감하지 않은 일반적인 기법이 바람직하다.

### 운영체제의 구현

커널의 가장 낮은 단계는 어셈블리어로 구현될 수 있고, 그 보다 높은 단계의 루틴은 C언어, 시스템 프로그램은 C, C++ Python 또는 셸 스크립트와 같은 언어로 구현될 수 있다. 운영체제가 고급 수준 언어로 작성되었을 경우 이식(다른 하드웨어로 옮기는 일)이 훨씬 쉽다. 하지만 속도가 느리고 저장 장치가 많이 소요될 수 있다. OS의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료 구조와 알고리즘의 결과일 가능성이 크다.

<br>

## 2.7 운영체제 구조

---

앞의 1장에서 배웠던 운영체제 구조(multiprogramming, Time sharing)은 일반적인 구성요소를 설명한 것, 이번 장에선 이러한 요소들이 어떻게 상호 연결되고 하나의 커널로 결합되는지 다룬다.

### Simple Struture

![image](https://user-images.githubusercontent.com/48276682/146894167-7b140b17-a439-43ba-8c3d-93e678708eeb.png)

하드웨어 자체가 제한적이므로 하드웨어에 직접 접근할 수 밖에 없었다.

### MS-Dos

- 최소의 공간에 최대의 기능들을 제공하도록 구현되었기 때문에 모듈별로 구분되지 않음
- 인터페이스와 기능 계층이 분리되어 있지 않음
- 사용자 프로그램이 고장나면 시스템 전체가 고장

### UNIX

- 커널과 시스템 프로그램으로 구성
- **Monolitihc 구조**: 시스템 호출 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널이므로 하나의 계층으로 결합하기에는 너무 많은 기능, 완벽하게 계층화되지 않음
- 구현, 유지보수가 어렵지만, 시스템 호출 인터페이스나 커널 안에서 통신하는 경우 오버헤드가 거의 없으므로 성능이 높음
- UNIX, Linux, Window 운영체제에서 이러한 구조는 여전히 남아있음

### 계층적 접근(Layered Approach)

![image](https://user-images.githubusercontent.com/48276682/146894855-3d6c6bb3-8047-4dd4-905a-88fc953816be.png){: width="40%" height="40%"}

- 시스템을 모듈화
- 운영체제 층은 자료 구조와 상위 층에서 호출할 수 있는 루틴의 집합으로 구성됨
- 가장 아래 계층은 하드웨어, 가장 높은 계층은 사용자 인터페이스
- 각 층은 자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해 구현함
- **장점**: 하나의 계층만 신경쓰면 되므로 구현, 디버깅이 간단하고 유지보수가 편함
- **단점**: 층을 적절히 정의하는 것의 어려움, 효율성 낮음. 각 층은 System call에 오버헤드를 추가하며 System call의 수행 시간이 더 오래 걸리게 됨

### 마이크로 커널(MicroKernal)

![image](https://user-images.githubusercontent.com/48276682/146896481-781a96ae-a669-43e0-800f-a2bbc9dc9959.png){: width="70%" height="70%"}

- Mac OS의 커널(darwin)
- **보다 작은 커널**: 모든 중요치 않은 구성 요소를 커널로부터 제거하고, 그것들을 시스템 및 사용자 수준 프로그램으로 구현해 운영체제를 구성함
- Message passing에 의해 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공
- **장점**: 운영체제의 확장에 용이함. 새로운 서비스는 사용자 공간에 추가되고 커널의 변경이 필요 없음 -> 보다 높은 보안성과 신뢰성
- **단점**: 가중된 시스템 기능 오버헤드 때문에 좋지 않은 성능

### 모듈(Modules)

![image](https://user-images.githubusercontent.com/48276682/146897306-9821c567-900e-46bc-9acf-6695b5d449ad.png){: width="70%" height="70%"}

- 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현, **서비스를 동적으로 링크함**
- 커널의 각 부분이 정의되고 보호된 인터페이스를 가지는 점은 계층 구조와 비슷하지만 모듈에서 임의의 다른 모듈을 호출할 수 있으므로 **더 유연함**
- 중심 모듈은 핵심 기능만 가지고, 다른 모듈의 적재 방법과 통신 방법을 안다는 점은 마이크로 커널과 유사하지만 통신을 위해 Message passing이 필요없으므로 **더 효율적임**
- 가장 일반적인 방법, 윈도우의 `.dll` 파일

### Hybrid System

- 대부분의 OS는 다양한 구조를 결합한 구조
- Linux, Solaris: 운영체제가 전부 하나의 주소 공간에 존재하는 모놀리식 구조이지만 모듈을 사용하여 기능을 동적으로 커널에 추가
- Window: 성능 상 이유로 대체로 모놀리식 구조이지만 서브시스템을 마이크로커널 형태로 유지, 모듈도 지원
- MacOS: Hybrid System, 커널의 핵심만 남기고 나머지는 따로 구현

<br>

## 2.8 운영체제 디버깅

---

### 디버깅

- 하드웨어와 소프트웨어에서의 시스템 오류를 발견하고 수정
- 시스템 처리 중에 발생하는 병목 현상을 제거 해 성능 향상시키려는 **성능 조정**도 포함

### 장애 분석

- OS는 에러 정보가 담긴 logfile 생성
- 프로세스가 사용하던 메모리를 캡쳐한 코어 덤프 파일로 저장 -> 디버거에 의해 검사
- Crush dump: 커널 장애(Crash) 또한 기록되고 저장
- Core dump와 Crush dump는 서로 다른 도구와 기법으로 디버깅

### 성능 조정(Performance Tuning)

- 병목 지점 제거
- 작업관리자: 시스템 성능 감시

### DTrace

- 실행중인 시스템, 프로세스와 커널에 동적으로 탐색점 추가
- 동적이고 안전하며 낮은 영향력을 미치는 디버깅 환경 제공

<br>

## 2.9 운영체제 생성

---

운영체제는 보통 디스크나 CD-ROM, DVD-ROM 또는 ISO 이미지로 배포된다. ISO 이미지는 CD-ROM 또는 DVD-ROM의 형태를 가지는 파일을 말한다.

### 시스템 생성, SYSGEN

- 시스템의 각 특정 컴퓨터 사이트를 위해 구성되거나 생성되는 절차
- 하드웨어 System의 특정 구성의 정보를 얻음
- 커널 또는 성능 조정 빌드를 위해 쓰임

<br>

## 2.10 시스템 부트

---

### BootStrap

- 작은 크기의 코드로, 커널을 찾고 메모리에 적재하고 수행
- 운영체제의 크기가 작거나 간단한 경우 비휘발성인 ROM에 저장
- 문제점: 코드가 변경되면 칩을 변경해야 함 -> **EEPROM**에 저장하여 쓰기 가능하도록 만드는 명령어가 주어지기 전까지는 읽기 전용 상태를 유지함
- **Firmware**: 하드웨어와 소프트웨어의 중간적 특성을 가지는 ROM의 모든 형태, RAM에서 실행시킬 때보다 실행 속도가 떨어지므로 OS를 firmware에 저장하고 실행 시엔 RAM으로 복사하여 실행함
- 대부분의 시스템에서 부트스트랩 로더는 Firmware에 있고 운영체제는 디스크에 존재함
